// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "server/proto/Admin.proto" (package "admin", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message admin.Admin
 */
export interface Admin {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: string email = 2
     */
    email: string;
    /**
     * @generated from protobuf field: string role = 3
     */
    role: string;
    /**
     * @generated from protobuf field: string phone = 4
     */
    phone: string;
    /**
     * @generated from protobuf field: int64 otp = 5
     */
    otp: bigint;
    /**
     * @generated from protobuf field: double otpExpiry = 6
     */
    otpExpiry: number; // Unix timestamp in seconds
    /**
     * @generated from protobuf field: string APIKey = 7
     */
    aPIKey: string;
    /**
     * @generated from protobuf field: string uuid = 8
     */
    uuid: string; // Unique identifier for the admin
    /**
     * @generated from protobuf field: string jwt = 9
     */
    jwt: string; // JWT token for authentication
    /**
     * @generated from protobuf field: bool emailVerified = 10
     */
    emailVerified: boolean; // Indicates if the email is verified
    /**
     * @generated from protobuf field: string createdAt = 11
     */
    createdAt: string; // Timestamp of when the admin was created
    /**
     * @generated from protobuf field: string updatedAt = 12
     */
    updatedAt: string; // Timestamp of when the admin was last updated
}
/**
 * @generated from protobuf message admin.CreateAdminUserRequest
 */
export interface CreateAdminUserRequest {
    /**
     * @generated from protobuf field: string recaptchaToken = 1
     */
    recaptchaToken: string; // Recaptcha token for validation
    /**
     * @generated from protobuf field: admin.Admin admin = 2
     */
    admin?: Admin; // Admin details to be created 
}
/**
 * @generated from protobuf message admin.CreateAdminUserResponse
 */
export interface CreateAdminUserResponse {
    /**
     * @generated from protobuf field: bool adminCreated = 1
     */
    adminCreated: boolean; // Created admin details
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string; // Message regarding the creation status
}
/**
 * @generated from protobuf message admin.GetAndValidateAdminRequest
 */
export interface GetAndValidateAdminRequest {
    /**
     * @generated from protobuf field: string email = 1
     */
    email: string; // Email of the admin to be validated
}
/**
 * @generated from protobuf message admin.ValidateAdminResponse
 */
export interface ValidateAdminResponse {
    /**
     * @generated from protobuf field: bool isValid = 1
     */
    isValid: boolean; // Indicates if the admin is valid
    /**
     * @generated from protobuf field: admin.Admin admin = 2
     */
    admin?: Admin; // Admin details if valid
    /**
     * @generated from protobuf field: bool isEmailVerified = 3
     */
    isEmailVerified: boolean; // Indicates if the email is verified
    /**
     * @generated from protobuf field: string message = 4
     */
    message: string; // Message regarding the validation status
}
/**
 * This message can be empty, used to fetch all admins
 *
 * @generated from protobuf message admin.AllAdmins
 */
export interface AllAdmins {
}
/**
 * @generated from protobuf message admin.OtpRequest
 */
export interface OtpRequest {
    /**
     * @generated from protobuf field: string email = 1
     */
    email: string; // Email of the admin to send OTP
}
/**
 * @generated from protobuf message admin.OtpResponse
 */
export interface OtpResponse {
    /**
     * @generated from protobuf field: bool otpSent = 1
     */
    otpSent: boolean; // Indicates if the OTP was sent successfully
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string; // Message regarding the OTP status
}
/**
 * @generated from protobuf message admin.OtpVerificationRequest
 */
export interface OtpVerificationRequest {
    /**
     * @generated from protobuf field: string email = 1
     */
    email: string; // Email of the admin for OTP verification
    /**
     * @generated from protobuf field: string otp = 2
     */
    otp: string; // OTP to verify
}
/**
 * @generated from protobuf message admin.OtpVerificationResponse
 */
export interface OtpVerificationResponse {
    /**
     * @generated from protobuf field: bool isVerified = 1
     */
    isVerified: boolean; // Indicates if the OTP verification was successful
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string; // Message regarding the verification status
}
/**
 * @generated from protobuf message admin.GetASpecificAdminRequest
 */
export interface GetASpecificAdminRequest {
    /**
     * @generated from protobuf field: string uuid = 1
     */
    uuid: string; // Unique identifier of the admin to fetch
}
/**
 * @generated from protobuf message admin.GetASpecificAdminResponse
 */
export interface GetASpecificAdminResponse {
    /**
     * @generated from protobuf field: admin.Admin admin = 1
     */
    admin?: Admin; // Admin details if found
}
/**
 * @generated from protobuf message admin.AdminUpdateRequest
 */
export interface AdminUpdateRequest {
    /**
     * @generated from protobuf field: admin.Admin admin = 1
     */
    admin?: Admin; // Admin details to be updated
}
/**
 * @generated from protobuf message admin.AdminUpdateResponse
 */
export interface AdminUpdateResponse {
    /**
     * @generated from protobuf field: bool isUpdated = 1
     */
    isUpdated: boolean; // Indicates if the admin was updated successfully
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string; // Message regarding the update status
}
/**
 * @generated from protobuf message admin.DeleteAdminRequest
 */
export interface DeleteAdminRequest {
    /**
     * @generated from protobuf field: string uuid = 1
     */
    uuid: string; // Unique identifier of the admin to delete
}
/**
 * @generated from protobuf message admin.DeleteAdminResponse
 */
export interface DeleteAdminResponse {
    /**
     * @generated from protobuf field: bool isDeleted = 1
     */
    isDeleted: boolean; // Indicates if the admin was deleted successfully
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string; // Message regarding the deletion status
}
/**
 * @generated from protobuf message admin.TokenValidationRequest
 */
export interface TokenValidationRequest {
    /**
     * @generated from protobuf field: string token = 1
     */
    token: string; // JWT token to validate
}
/**
 * @generated from protobuf message admin.TokenValidationResponse
 */
export interface TokenValidationResponse {
    /**
     * @generated from protobuf field: bool isValid = 1
     */
    isValid: boolean; // Indicates if the token is valid
    /**
     * @generated from protobuf field: string email = 2
     */
    email: string; // Message regarding the token validation status
}
// @generated message type with reflection information, may provide speed optimized methods
class Admin$Type extends MessageType<Admin> {
    constructor() {
        super("admin.Admin", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "phone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "otp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "otpExpiry", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "APIKey", kind: "scalar", jsonName: "APIKey", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "jwt", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "emailVerified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "createdAt", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "updatedAt", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Admin>): Admin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.email = "";
        message.role = "";
        message.phone = "";
        message.otp = 0n;
        message.otpExpiry = 0;
        message.aPIKey = "";
        message.uuid = "";
        message.jwt = "";
        message.emailVerified = false;
        message.createdAt = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<Admin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Admin): Admin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string email */ 2:
                    message.email = reader.string();
                    break;
                case /* string role */ 3:
                    message.role = reader.string();
                    break;
                case /* string phone */ 4:
                    message.phone = reader.string();
                    break;
                case /* int64 otp */ 5:
                    message.otp = reader.int64().toBigInt();
                    break;
                case /* double otpExpiry */ 6:
                    message.otpExpiry = reader.double();
                    break;
                case /* string APIKey */ 7:
                    message.aPIKey = reader.string();
                    break;
                case /* string uuid */ 8:
                    message.uuid = reader.string();
                    break;
                case /* string jwt */ 9:
                    message.jwt = reader.string();
                    break;
                case /* bool emailVerified */ 10:
                    message.emailVerified = reader.bool();
                    break;
                case /* string createdAt */ 11:
                    message.createdAt = reader.string();
                    break;
                case /* string updatedAt */ 12:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Admin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string email = 2; */
        if (message.email !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.email);
        /* string role = 3; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* string phone = 4; */
        if (message.phone !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.phone);
        /* int64 otp = 5; */
        if (message.otp !== 0n)
            writer.tag(5, WireType.Varint).int64(message.otp);
        /* double otpExpiry = 6; */
        if (message.otpExpiry !== 0)
            writer.tag(6, WireType.Bit64).double(message.otpExpiry);
        /* string APIKey = 7; */
        if (message.aPIKey !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.aPIKey);
        /* string uuid = 8; */
        if (message.uuid !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.uuid);
        /* string jwt = 9; */
        if (message.jwt !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.jwt);
        /* bool emailVerified = 10; */
        if (message.emailVerified !== false)
            writer.tag(10, WireType.Varint).bool(message.emailVerified);
        /* string createdAt = 11; */
        if (message.createdAt !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.createdAt);
        /* string updatedAt = 12; */
        if (message.updatedAt !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.Admin
 */
export const Admin = new Admin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAdminUserRequest$Type extends MessageType<CreateAdminUserRequest> {
    constructor() {
        super("admin.CreateAdminUserRequest", [
            { no: 1, name: "recaptchaToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "admin", kind: "message", T: () => Admin }
        ]);
    }
    create(value?: PartialMessage<CreateAdminUserRequest>): CreateAdminUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recaptchaToken = "";
        if (value !== undefined)
            reflectionMergePartial<CreateAdminUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAdminUserRequest): CreateAdminUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recaptchaToken */ 1:
                    message.recaptchaToken = reader.string();
                    break;
                case /* admin.Admin admin */ 2:
                    message.admin = Admin.internalBinaryRead(reader, reader.uint32(), options, message.admin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAdminUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recaptchaToken = 1; */
        if (message.recaptchaToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recaptchaToken);
        /* admin.Admin admin = 2; */
        if (message.admin)
            Admin.internalBinaryWrite(message.admin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.CreateAdminUserRequest
 */
export const CreateAdminUserRequest = new CreateAdminUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAdminUserResponse$Type extends MessageType<CreateAdminUserResponse> {
    constructor() {
        super("admin.CreateAdminUserResponse", [
            { no: 1, name: "adminCreated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateAdminUserResponse>): CreateAdminUserResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.adminCreated = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<CreateAdminUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAdminUserResponse): CreateAdminUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool adminCreated */ 1:
                    message.adminCreated = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAdminUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool adminCreated = 1; */
        if (message.adminCreated !== false)
            writer.tag(1, WireType.Varint).bool(message.adminCreated);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.CreateAdminUserResponse
 */
export const CreateAdminUserResponse = new CreateAdminUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAndValidateAdminRequest$Type extends MessageType<GetAndValidateAdminRequest> {
    constructor() {
        super("admin.GetAndValidateAdminRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAndValidateAdminRequest>): GetAndValidateAdminRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.email = "";
        if (value !== undefined)
            reflectionMergePartial<GetAndValidateAdminRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAndValidateAdminRequest): GetAndValidateAdminRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAndValidateAdminRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.GetAndValidateAdminRequest
 */
export const GetAndValidateAdminRequest = new GetAndValidateAdminRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateAdminResponse$Type extends MessageType<ValidateAdminResponse> {
    constructor() {
        super("admin.ValidateAdminResponse", [
            { no: 1, name: "isValid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "admin", kind: "message", T: () => Admin },
            { no: 3, name: "isEmailVerified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateAdminResponse>): ValidateAdminResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isValid = false;
        message.isEmailVerified = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ValidateAdminResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateAdminResponse): ValidateAdminResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isValid */ 1:
                    message.isValid = reader.bool();
                    break;
                case /* admin.Admin admin */ 2:
                    message.admin = Admin.internalBinaryRead(reader, reader.uint32(), options, message.admin);
                    break;
                case /* bool isEmailVerified */ 3:
                    message.isEmailVerified = reader.bool();
                    break;
                case /* string message */ 4:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateAdminResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isValid = 1; */
        if (message.isValid !== false)
            writer.tag(1, WireType.Varint).bool(message.isValid);
        /* admin.Admin admin = 2; */
        if (message.admin)
            Admin.internalBinaryWrite(message.admin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool isEmailVerified = 3; */
        if (message.isEmailVerified !== false)
            writer.tag(3, WireType.Varint).bool(message.isEmailVerified);
        /* string message = 4; */
        if (message.message !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.ValidateAdminResponse
 */
export const ValidateAdminResponse = new ValidateAdminResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllAdmins$Type extends MessageType<AllAdmins> {
    constructor() {
        super("admin.AllAdmins", []);
    }
    create(value?: PartialMessage<AllAdmins>): AllAdmins {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AllAdmins>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllAdmins): AllAdmins {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllAdmins, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.AllAdmins
 */
export const AllAdmins = new AllAdmins$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OtpRequest$Type extends MessageType<OtpRequest> {
    constructor() {
        super("admin.OtpRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OtpRequest>): OtpRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.email = "";
        if (value !== undefined)
            reflectionMergePartial<OtpRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OtpRequest): OtpRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OtpRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.OtpRequest
 */
export const OtpRequest = new OtpRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OtpResponse$Type extends MessageType<OtpResponse> {
    constructor() {
        super("admin.OtpResponse", [
            { no: 1, name: "otpSent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OtpResponse>): OtpResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.otpSent = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<OtpResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OtpResponse): OtpResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool otpSent */ 1:
                    message.otpSent = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OtpResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool otpSent = 1; */
        if (message.otpSent !== false)
            writer.tag(1, WireType.Varint).bool(message.otpSent);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.OtpResponse
 */
export const OtpResponse = new OtpResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OtpVerificationRequest$Type extends MessageType<OtpVerificationRequest> {
    constructor() {
        super("admin.OtpVerificationRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "otp", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OtpVerificationRequest>): OtpVerificationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.email = "";
        message.otp = "";
        if (value !== undefined)
            reflectionMergePartial<OtpVerificationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OtpVerificationRequest): OtpVerificationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                case /* string otp */ 2:
                    message.otp = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OtpVerificationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        /* string otp = 2; */
        if (message.otp !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.otp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.OtpVerificationRequest
 */
export const OtpVerificationRequest = new OtpVerificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OtpVerificationResponse$Type extends MessageType<OtpVerificationResponse> {
    constructor() {
        super("admin.OtpVerificationResponse", [
            { no: 1, name: "isVerified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OtpVerificationResponse>): OtpVerificationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isVerified = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<OtpVerificationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OtpVerificationResponse): OtpVerificationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isVerified */ 1:
                    message.isVerified = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OtpVerificationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isVerified = 1; */
        if (message.isVerified !== false)
            writer.tag(1, WireType.Varint).bool(message.isVerified);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.OtpVerificationResponse
 */
export const OtpVerificationResponse = new OtpVerificationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetASpecificAdminRequest$Type extends MessageType<GetASpecificAdminRequest> {
    constructor() {
        super("admin.GetASpecificAdminRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetASpecificAdminRequest>): GetASpecificAdminRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<GetASpecificAdminRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetASpecificAdminRequest): GetASpecificAdminRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetASpecificAdminRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.GetASpecificAdminRequest
 */
export const GetASpecificAdminRequest = new GetASpecificAdminRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetASpecificAdminResponse$Type extends MessageType<GetASpecificAdminResponse> {
    constructor() {
        super("admin.GetASpecificAdminResponse", [
            { no: 1, name: "admin", kind: "message", T: () => Admin }
        ]);
    }
    create(value?: PartialMessage<GetASpecificAdminResponse>): GetASpecificAdminResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetASpecificAdminResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetASpecificAdminResponse): GetASpecificAdminResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* admin.Admin admin */ 1:
                    message.admin = Admin.internalBinaryRead(reader, reader.uint32(), options, message.admin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetASpecificAdminResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* admin.Admin admin = 1; */
        if (message.admin)
            Admin.internalBinaryWrite(message.admin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.GetASpecificAdminResponse
 */
export const GetASpecificAdminResponse = new GetASpecificAdminResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdminUpdateRequest$Type extends MessageType<AdminUpdateRequest> {
    constructor() {
        super("admin.AdminUpdateRequest", [
            { no: 1, name: "admin", kind: "message", T: () => Admin }
        ]);
    }
    create(value?: PartialMessage<AdminUpdateRequest>): AdminUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AdminUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdminUpdateRequest): AdminUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* admin.Admin admin */ 1:
                    message.admin = Admin.internalBinaryRead(reader, reader.uint32(), options, message.admin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdminUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* admin.Admin admin = 1; */
        if (message.admin)
            Admin.internalBinaryWrite(message.admin, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.AdminUpdateRequest
 */
export const AdminUpdateRequest = new AdminUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdminUpdateResponse$Type extends MessageType<AdminUpdateResponse> {
    constructor() {
        super("admin.AdminUpdateResponse", [
            { no: 1, name: "isUpdated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AdminUpdateResponse>): AdminUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isUpdated = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<AdminUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdminUpdateResponse): AdminUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isUpdated */ 1:
                    message.isUpdated = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdminUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isUpdated = 1; */
        if (message.isUpdated !== false)
            writer.tag(1, WireType.Varint).bool(message.isUpdated);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.AdminUpdateResponse
 */
export const AdminUpdateResponse = new AdminUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAdminRequest$Type extends MessageType<DeleteAdminRequest> {
    constructor() {
        super("admin.DeleteAdminRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteAdminRequest>): DeleteAdminRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteAdminRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAdminRequest): DeleteAdminRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteAdminRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.DeleteAdminRequest
 */
export const DeleteAdminRequest = new DeleteAdminRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAdminResponse$Type extends MessageType<DeleteAdminResponse> {
    constructor() {
        super("admin.DeleteAdminResponse", [
            { no: 1, name: "isDeleted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteAdminResponse>): DeleteAdminResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isDeleted = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteAdminResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAdminResponse): DeleteAdminResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isDeleted */ 1:
                    message.isDeleted = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteAdminResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isDeleted = 1; */
        if (message.isDeleted !== false)
            writer.tag(1, WireType.Varint).bool(message.isDeleted);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.DeleteAdminResponse
 */
export const DeleteAdminResponse = new DeleteAdminResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenValidationRequest$Type extends MessageType<TokenValidationRequest> {
    constructor() {
        super("admin.TokenValidationRequest", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenValidationRequest>): TokenValidationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<TokenValidationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenValidationRequest): TokenValidationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenValidationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.TokenValidationRequest
 */
export const TokenValidationRequest = new TokenValidationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenValidationResponse$Type extends MessageType<TokenValidationResponse> {
    constructor() {
        super("admin.TokenValidationResponse", [
            { no: 1, name: "isValid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenValidationResponse>): TokenValidationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isValid = false;
        message.email = "";
        if (value !== undefined)
            reflectionMergePartial<TokenValidationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenValidationResponse): TokenValidationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isValid */ 1:
                    message.isValid = reader.bool();
                    break;
                case /* string email */ 2:
                    message.email = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenValidationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isValid = 1; */
        if (message.isValid !== false)
            writer.tag(1, WireType.Varint).bool(message.isValid);
        /* string email = 2; */
        if (message.email !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.email);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message admin.TokenValidationResponse
 */
export const TokenValidationResponse = new TokenValidationResponse$Type();
/**
 * @generated ServiceType for protobuf service admin.AdminService
 */
export const AdminService = new ServiceType("admin.AdminService", [
    { name: "CreateAdmin", options: {}, I: CreateAdminUserRequest, O: CreateAdminUserResponse },
    { name: "GetAllAdmins", serverStreaming: true, options: {}, I: AllAdmins, O: Admin },
    { name: "ValidateAdmin", options: {}, I: GetAndValidateAdminRequest, O: ValidateAdminResponse },
    { name: "SendOtp", options: {}, I: OtpRequest, O: OtpResponse },
    { name: "VerifyOtp", options: {}, I: OtpVerificationRequest, O: OtpVerificationResponse },
    { name: "LoginAdmin", options: {}, I: OtpRequest, O: OtpResponse },
    { name: "GetSpecificAdmin", options: {}, I: GetASpecificAdminRequest, O: GetASpecificAdminResponse },
    { name: "UpdateAdmin", options: {}, I: AdminUpdateRequest, O: AdminUpdateResponse },
    { name: "DeleteAdmin", options: {}, I: DeleteAdminRequest, O: DeleteAdminResponse },
    { name: "ValidateToken", options: {}, I: TokenValidationRequest, O: TokenValidationResponse }
]);
